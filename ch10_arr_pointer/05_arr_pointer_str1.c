/*
C언어(절차지향)는 문자열 자료형 지원X
 → 그래서 문자열을 char배열로 표현

문자 배열(문자열)
 → 문자열은 크기가 일정X(컴파일러는 문자열 '상수'를 독특한 방법으로 처리)
 - 컴파일 과정에서 문자열을 char배열 형태로 보관하고 문자여 상수가 있던 곳에는 배열의 위치값 사용
    ex)
    char fruit[6] = "apple"은 'a'가 저장된 메모리 주소값으로 바뀜       // 문자열 자체를 넣을 땐 알아서 널 문자 붙음. 각 글자 하나하나에 값 할당할 땐 널 문자 붙여줘야 함.
 - 문자열은 다른 자료형과 달리 크기가 매우 상이(by글자수)
 - 문자열을 주소로 바꾸면 포인터 연산을 통해 시작 위치부터 길이 제한 없이 사용 가능
 - 이 경우 문자열의 끝을 알아야 하므로 널 문자 사용해서 끝 표시
 - 컴파일러 또한 문자열 상수를 따로 저장할 때 마지막에 항상 널 문자 붙임 
 ※ 운영체제는 문자열 상수를 읽기 전용 메모리 영역에 저장
    따라서, 그 값을 바꾸는 명령 실행을 제한함. 바꾸려 하지 말고 새 값 만들어라 그냥..
    ex)
    "apple"='t'; 코드상으론 문제X, but 실행시 "강제 종료"
 ※ 자료형에 따른 scanf() 사용법
    ex)
    int num = 4;
    char name[4] = "ccw";
    int ary[3] = {10, 20, 30};
    scanf("%d", &num);     
    scanf("%s", name);     // 문자열 받을 땐 주소 연산자 & 안 씀. 그 자체가 주소라서.
    // 배열명 → 첫 번째 요소의 시작 주소
    // - ary(주소) + 1 → 주소 연산. 주소이므로 & 안 붙인다.
    // - ary[2] → 세 번째 요소의 값. & 붙여야 함.
    scanf("%d", &ary[2]);
    scanf("%d", ary+2);

 ※ 객체지향언어의 Mutable Types와 Immutable Types
    1. Mutable Types : 생성 후 수정 가능한 자료형
     - List, Dict, ...etc.
    2. Immutable  "  : 생성 후 수정 불가능한 자료형 
     - String(문자열), Tuple, ...etc.
    → C언어는 절차지향이기에 위 타입들을 사용하진 않지만 문자열은 2번과 비슷하다고 생각하면 쉬움.

*/

#include <stdio.h>
int main(){
    printf("apple이 저장된 시작 주소 값 : %u\n", "apple");
    printf("두 번째 문자 주소 값 : %u\n", "apple"+1);
    printf("첫 번째 문자 : %c\n", ("apple"));
    printf("두 번째 문자 : %c\n", ("apple"+1));
    printf("배열로 표현한 세 번째 문자 : %c\n", "apple"[2]);


}